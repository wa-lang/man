## 5.1. 引用

在凹语言中，在一个变量前添加 `&` 符号被称为 **取引用** 操作，假设该变量的类型为 `T`，取引用操作返回值的类型为 `*T`，被称为 **T型引用**，例如：
```wa
    i: i32 = 42
    j := &i // j的类型为 *i32 ，既：i32型引用
```

在引用型变量前添加 `*` 符号被称为 **解引用** 操作，解引用表达式的值为它所引用的原始变量的值，例如：
```wa
    i: i32 = 42
    j := &i
    println(*j) // 42
```

在这里 `*j` 返回了 `i` 的值，类型与 `i` 一样为 `i32`。解引用可以被赋值，其作用为向被引用的原始变量赋值，例如：
```wa
    i: i32 = 13
    j := &i
    *j = 42
    println(i) // 42
```

由此可见，凹语言中的**引用**与C系语言中的**指针**作用类似，但由于凹语言使用自动内存管理，这种相似性仅存在于表面，因此我们使用**引用**这一术语以示区别。二者最显著的不同，可通过下面这个例子窥见一斑：
```wa
// 版权 @2023 凹语言 作者。保留所有权利。

func genI32Ref() => *i32 {
    i: i32 = 9527
    return &i
}

func main {
    p := genI32Ref()
    *p = 13
    q := genI32Ref()
    println(*p) // 13
    println(*q) // 9527
}
```

在凹语言中，**跨函数传递引用是合法操作**。返回局部变量的引用安全无害，编译器和运行时会跟踪变量使用的内存，自动执行清理回收。当然这导致了引用与指针的另一个直观的不同，既：引用不能执行算术运算。

对于引用类型 `*T`，`T` 可以是基础类型，也可以是任何复合类型或自定义类型，`**T` 这样的多级引用（类似于C语言多级指针）也是合法的。

---

已知问题列表：
- 目前使用的RC模式无法自动回收孤环，进而导致内存泄漏。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。